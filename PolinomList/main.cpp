/*
Разработка стурктуры хранения для полиномов.
Пример: рассмотрим полином от трёх переменных
P(x,y,z) = 2x^5 * y^4 * z^3 + 10x^6 * y^7 * z^8 - 2 * x * y^3 - 3
Для простоты считаем, что степень переменных ограничена 10
Всего комбинаций 10^3
Полином редставляет сумму мономов

1 вариант запоминания
Зарезервировать в памяти вектор
Договориться что 0 ячейка хранит коэффциент свободного члена: -3
Считаем x, y, z где x приоритет
-2*x*y^2 это ячейка с номером 120 в которой хранится -2
10x^6 * y^7 * z^8 - ячейка 678 где хранится 10

Минусы: большой расход памяти, многие ячейки не используются

2 вариант с использованием списков
Для однозначного представления полинома договоримся, что мономы в полиноме хранятся упорядоченно по порядку степеней.
Все мономы в списке будут хранится по убыванию их степеней.
Тогда список можно представить следующими виде:
[10, 678][]->[2, 543][]->[-2, 120][]->[-3, 000][0]
Операции с полиномами:
пусть есть полином Q(x, y, z) = 2*x*y^2
P + Q = Z
При выполнении операций с полиномами возникает ситуация когда коэф. равны 0, то есть хранить их уже будет не нужно и моном нужно удалить.
P - P = 0
Как представить пустой полином?
неоднозначность: nullptr может представлять пустой или же что его вообще нет.
Решение:
1) Можем договориться что nullptr это нулевой полином. Тогда нужно отличать ситуацию: плохой полином и нулевой полином.
2) В каждый полином добавить фиктивное звено, которое будет соответствовать нулевому полиному. Добавим его в начало. [0, -1][]->...
Оно никогда не будет уничтожаться и является признаком пустого полинома.

Что должна делать программа:
1) Позволять создавать полиномы
2) Выполнять действия над полиномами

1) Значит мы объявляем полином и каким-то образом вводим моном, которые определяются коэф. и степенями. Признаком конца ввода является нулевое значение коэффциента.
2) Сложение, вычитание, домножать на константу/моном, произведение двух полиномов(*)

варианты ввода:
1) консоль
2) графическое приложение

Можно сделать вектор полиномов, в котором хранить промежуточные результаты.
Для отображения:
1. P
2. Q
3. P+Q
4. P*2
Можно любой распечатать и посмотреть результат.

По этой программы нужно подготовить отчёт.
Задача оформляется как лаб. работа.
Должно быть пункты
Постановка задачи
Описание алгоритма и структур данных.

Пример отчёта покажут и сбросят (со скалы)

Реализация
1) структура хранения мономов

Визуальная часть:
1) можно написать полином и его добавить
2) поля для добавления монома и его добавление к текущему моному + отдельная кнопка для добавления полинома к общему списку
Тесты:
Моном: Задаём 2 монома, и сравниваем их.
Список: созданиие, добавление, удаление
Попробуем написать класс итератор для списка.
*/
#include "polinom.h"
int main() {
	// 1 способ,
	/*TList<int> l;
	for (l.reset(); !l.isEnd(); l.goNext()) {
		std::cout << l.getCurr();
	}*/
	// должен перебрать все элементы списка.
	// есть ф-ция которая возвращает текущий элемент списка

	// 2 способ(нужно выполнить). Написать приближенный класс к итератору из стандартной библиотеки.
	Polinom pol1;
	pol1 += Monom(3.0, 0, 0, 0);
	pol1 += Monom(2.0, 1, 1, 1);
	pol1 += Monom(5.0, 2, 1, 0);
	Polinom pol2;
	pol2 += Monom(3.0, 0, 3, 0);
	pol2 += Monom(-2.0, 1, 1, 1);
	pol2 += Monom(5.0, 0, 1, 2);
	Polinom res;
	Monom m = pol1[0];
	m *= pol2[2];
	std::cout << m << std::endl;
	res = pol1 * pol2;
	Polinom::iterator q = res.begin();
	std::cout << "Monoms:" << std::endl;
	for (q = res.begin(); q != res.end() ; ++q)
	{
		std::cout << (*q) << " ";
	}
	std::cout << std::endl;
	std::cout << "Polinom:" << std::endl;
	std::cout << res;
	return 0;
}